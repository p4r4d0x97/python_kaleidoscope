from flask import Flask, render_template, request
from flask_socketio import SocketIO, emit
import sqlite3
import ipaddress
import asyncio
import time
from datetime import datetime, timedelta
import platform
import subprocess
import threading

app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret!'
socketio = SocketIO(app)


# Database initialization
def init_db():
    with sqlite3.connect('ip_status.db') as conn:
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS ip_status
                     (ip TEXT PRIMARY KEY, vlan INTEGER, status TEXT, last_seen TEXT, uptime_start TEXT)''')
        c.execute('''CREATE TABLE IF NOT EXISTS session_history
                     (id INTEGER PRIMARY KEY AUTOINCREMENT, ip TEXT, start_time TEXT, end_time TEXT)''')
        conn.commit()


# Sample VLANs and IPs
vlans = [
    {'id': 10, 'network': '192.168.1.0/24'},
    {'id': 20, 'network': '192.168.2.0/24'},
]


def get_all_ips():
    ips = []
    with sqlite3.connect('ip_status.db') as conn:
        c = conn.cursor()
        for vlan in vlans:
            network = ipaddress.ip_network(vlan['network'])
            for ip in network.hosts():
                ip_str = str(ip)
                c.execute('SELECT * FROM ip_status WHERE ip=?', (ip_str,))
                result = c.fetchone()
                if not result:
                    c.execute(
                        'INSERT OR IGNORE INTO ip_status (ip, vlan, status, last_seen, uptime_start) VALUES (?, ?, ?, ?, ?)',
                        (ip_str, vlan['id'], 'no_data', 'N/A', 'N/A'))
                else:
                    c.execute('UPDATE ip_status SET vlan=? WHERE ip=?', (vlan['id'], ip_str))
                c.execute('SELECT * FROM ip_status WHERE ip=?', (ip_str,))
                result = c.fetchone()
                ips.append({
                    'ip': ip_str,
                    'vlan': result[1],
                    'status': result[2],
                    'last_seen': result[3],
                    'uptime_start': result[4]
                })
        conn.commit()
    return ips


async def ping_ip(ip):
    param = '-n' if platform.system().lower() == 'windows' else '-c'
    cmd = ['ping', param, '1', '-w', '2', ip]
    try:
        process = await asyncio.create_subprocess_exec(*cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        await process.communicate()
        return process.returncode == 0
    except:
        return False


async def ping_vlan(vlan_ips, conn, cursor):
    tasks = [ping_ip(ip['ip']) for ip in vlan_ips]
    results = await asyncio.gather(*tasks)

    for ip, result in zip(vlan_ips, results):
        now = datetime.now().isoformat()
        cursor.execute('SELECT status, uptime_start FROM ip_status WHERE ip=?', (ip['ip'],))
        current = cursor.fetchone()
        new_status = 'online' if result else 'offline'

        if current[0] != new_status:
            if result:
                cursor.execute('UPDATE ip_status SET status=?, uptime_start=?, last_seen=? WHERE ip=?',
                               (new_status, now, now, ip['ip']))
                cursor.execute('INSERT INTO session_history (ip, start_time) VALUES (?, ?)',
                               (ip['ip'], now))
            else:
                cursor.execute('UPDATE ip_status SET status=?, last_seen=? WHERE ip=?',
                               (new_status, now, ip['ip']))
                if current[0] == 'online':
                    cursor.execute('UPDATE session_history SET end_time=? WHERE ip=? AND end_time IS NULL',
                                   (now, ip['ip']))
            socketio.emit('status_change', {
                'ip': ip['ip'],
                'vlan': ip['vlan'],
                'status': new_status,
                'timestamp': now
            })
        elif current[0] == 'online':
            cursor.execute('UPDATE ip_status SET last_seen=? WHERE ip=?', (now, ip['ip']))

    conn.commit()


def run_ping_loop():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    while True:
        with sqlite3.connect('ip_status.db') as conn:
            cursor = conn.cursor()
            for i in range(0, len(vlans), 2):
                vlan_group = vlans[i:i + 2]
                vlan_ips = []
                for vlan in vlan_group:
                    network = ipaddress.ip_network(vlan['network'])
                    vlan_ips.extend({'ip': str(ip), 'vlan': vlan['id']} for ip in network.hosts())

                loop.run_until_complete(ping_vlan(vlan_ips, conn, cursor))
                time.sleep(5)

    loop.close()


@app.route('/')
def index():
    refresh_interval = request.args.get('refresh', '30')
    vlan_filter = request.args.get('vlan', '')
    ip_filter = request.args.get('ip', '')
    status_filter = request.args.get('status', '')
    page = int(request.args.get('page', 1))
    per_page = 10

    ips = get_all_ips()
    filtered_ips = []

    for ip in ips:
        if (not vlan_filter or str(ip['vlan']) == vlan_filter) and \
                (not ip_filter or ip_filter in ip['ip']) and \
                (not status_filter or ip['status'] == status_filter):
            if ip['status'] == 'online' and ip['uptime_start'] != 'N/A':
                uptime_start = datetime.fromisoformat(ip['uptime_start'])
                uptime = datetime.now() - uptime_start
                ip['uptime'] = str(timedelta(seconds=int(uptime.total_seconds())))
            else:
                ip['uptime'] = 'N/A'
            filtered_ips.append(ip)

    total_ips = len(filtered_ips)
    total_pages = (total_ips + per_page - 1) // per_page
    start = (page - 1) * per_page
    end = start + per_page
    paginated_ips = filtered_ips[start:end]

    return render_template('index.html',
                           ips=paginated_ips,
                           vlans=[vlan['id'] for vlan in vlans],
                           refresh_interval=refresh_interval,
                           page=page,
                           total_pages=total_pages,
                           total_ips=total_ips,
                           vlan_filter=vlan_filter,
                           ip_filter=ip_filter,
                           status_filter=status_filter)


@app.route('/history/<ip>')
def history(ip):
    with sqlite3.connect('ip_status.db') as conn:
        c = conn.cursor()
        c.execute('SELECT start_time, end_time FROM session_history WHERE ip=? ORDER BY start_time DESC', (ip,))
        sessions = c.fetchall()
        history = []
        for start, end in sessions:
            start_time = datetime.fromisoformat(start)
            end_time = datetime.fromisoformat(end) if end else None
            duration = (end_time - start_time) if end_time else 'Ongoing'
            history.append({
                'start': start_time.strftime('%Y-%m-%d %H:%M:%S'),
                'end': end_time.strftime('%Y-%m-%d %H:%M:%S') if end_time else 'Ongoing',
                'duration': str(duration)
            })
    return render_template('history.html', ip=ip, history=history)


@socketio.on('connect')
def handle_connect():
    emit('connected', {'message': 'Connected to notifications'})


if __name__ == '__main__':
    init_db()
    threading.Thread(target=run_ping_loop, daemon=True).start()
    socketio.run(app, debug=True)
