import asyncio
import platform
import subprocess
import ipaddress
import time
from datetime import datetime, timedelta
from flask import Flask, render_template, request, jsonify
from flask_socketio import SocketIO
import sqlite3
from threading import Lock
import json
from collections import defaultdict

app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret!'
socketio = SocketIO(app, async_mode='threading')

# Database setup
def init_db():
    with sqlite3.connect('network.db') as conn:
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS devices
                     (ip TEXT PRIMARY KEY, vlan INTEGER, status TEXT, last_seen REAL, first_seen REAL)''')
        c.execute('''CREATE TABLE IF NOT EXISTS history
                     (ip TEXT, start_time REAL, end_time REAL, duration REAL,
                      FOREIGN KEY(ip) REFERENCES devices(ip))''')
        conn.commit()

# VLAN configuration
vlans = [
    {'id': 10, 'network': '192.168.1.0/24'},
    {'id': 20, 'network': '192.168.2.0/24'},
    {'id': 30, 'network': '192.168.3.0/24'},
    {'id': 40, 'network': '192.168.4.0/24'}
]

# Thread-safe data storage
devices = defaultdict(lambda: {'status': 'No data', 'last_seen': 0, 'first_seen': 0})
notifications = []
lock = Lock()

# Ping function
async def ping_host(ip):
    param = '-n' if platform.system().lower() == 'windows' else '-c'
    cmd = ['ping', param, '1', str(ip)]
    try:
        output = await asyncio.create_subprocess_exec(
            *cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        await output.communicate()
        return output.returncode == 0
    except Exception:
        return False

# Update device status
def update_device_status(ip, vlan, is_online):
    with lock:
        now = time.time()
        with sqlite3.connect('network.db') as conn:
            c = conn.cursor()
            c.execute('SELECT status, first_seen FROM devices WHERE ip = ?', (ip,))
            result = c.fetchone()
            
            if is_online:
                if result and result[0] == 'Offline':
                    # Device came online
                    c.execute('UPDATE devices SET status = ?, last_seen = ?, first_seen = ? WHERE ip = ?',
                             ('Online', now, now, ip))
                    c.execute('INSERT INTO history (ip, start_time) VALUES (?, ?)', (ip, now))
                    if not request.args.get('ip') or request.args.get('ip') == ip or \
                       not request.args.get('vlan') or str(request.args.get('vlan')) == str(vlan):
                        notifications.append({'ip': ip, 'status': 'Online', 'time': now})
                        if len(notifications) > 5:
                            notifications.pop(0)
                        socketio.emit('notification', {'ip': ip, 'status': 'Online', 'time': datetime.fromtimestamp(now).strftime('%Y-%m-%d %H:%M:%S')})
                elif not result:
                    # New device
                    c.execute('INSERT INTO devices (ip, vlan, status, last_seen, first_seen) VALUES (?, ?, ?, ?, ?)',
                             (ip, vlan, 'Online', now, now))
                    c.execute('INSERT INTO history (ip, start_time) VALUES (?, ?)', (ip, now))
                    if not request.args.get('ip') or request.args.get('ip') == ip or \
                       not request.args.get('vlan') or str(request.args.get('vlan')) == str(vlan):
                        notifications.append({'ip': ip, 'status': 'Online', 'time': now})
                        if len(notifications) > 5:
                            notifications.pop(0)
                        socketio.emit('notification', {'ip': ip, 'status': 'Online', 'time': datetime.fromtimestamp(now).strftime('%Y-%m-%d %H:%M:%S')})
                devices[ip]['status'] = 'Online'
                devices[ip]['first_seen'] = result[1] if result else now
            else:
                if result and result[0] == 'Online':
                    # Device went offline
                    c.execute('UPDATE devices SET status = ?, last_seen = ? WHERE ip = ?',
                             ('Offline', now, ip))
                    c.execute('UPDATE history SET end_time = ?, duration = ? WHERE ip = ? AND end_time IS NULL',
                             (now, now - result[1], ip))
                    if not request.args.get('ip') or request.args.get('ip') == ip or \
                       not request.args.get('vlan') or str(request.args.get('vlan')) == str(vlan):
                        notifications.append({'ip': ip, 'status': 'Offline', 'time': now})
                        if len(notifications) > 5:
                            notifications.pop(0)
                        socketio.emit('notification', {'ip': ip, 'status': 'Offline', 'time': datetime.fromtimestamp(now).strftime('%Y-%m-%d %H:%M:%S')})
                elif not result:
                    c.execute('INSERT INTO devices (ip, vlan, status, last_seen) VALUES (?, ?, ?, ?)',
                             (ip, vlan, 'Offline', now))
                devices[ip]['status'] = 'Offline'
                devices[ip]['last_seen'] = now
            devices[ip]['vlan'] = vlan
            conn.commit()

# Async ping loop
async def ping_vlans():
    while True:
        for i in range(0, len(vlans), 2):
            tasks = []
            for vlan in vlans[i:i+2]:
                network = ipaddress.ip_network(vlan['network'])
                for ip in network.hosts():
                    tasks.append(ping_host(str(ip)))
                results = await asyncio.gather(*tasks)
                for ip, result in zip(network.hosts(), results):
                    await update_device_status(str(ip), vlan['id'], result)
            socketio.emit('update', dict(devices))
            await asyncio.sleep(5)
        await asyncio.sleep(30)  # Wait before next full cycle

# Flask routes
@app.route('/')
def index():
    page = int(request.args.get('page', 1))
    per_page = 10
    ip_filter = request.args.get('ip', '')
    vlan_filter = request.args.get('vlan', '')
    refresh_rate = int(request.args.get('refresh', 30))
    
    with sqlite3.connect('network.db') as conn:
        c = conn.cursor()
        query = 'SELECT ip, vlan, status, last_seen, first_seen FROM devices'
        params = []
        conditions = []
        if ip_filter:
            conditions.append('ip LIKE ?')
            params.append(f'%{ip_filter}%')
        if vlan_filter:
            conditions.append('vlan = ?')
            params.append(vlan_filter)
        if conditions:
            query += ' WHERE ' + ' AND '.join(conditions)
        query += ' ORDER BY ip'
        
        c.execute(query, params)
        all_devices = c.fetchall()
        total = len(all_devices)
        start = (page - 1) * per_page
        devices_paginated = all_devices[start:start + per_page]
        
        devices_data = []
        now = time.time()
        for device in devices_paginated:
            ip, vlan, status, last_seen, first_seen = device
            if status == 'Online':
                uptime = now - first_seen
                status_text = f"Online for {int(uptime // 60)}m {int(uptime % 60)}s"
            elif status == 'Offline' and last_seen:
                downtime = now - last_seen
                status_text = f"Last seen {int(downtime // 60)}m ago"
            else:
                status_text = "No data"
            devices_data.append({
                'ip': ip,
                'vlan': vlan,
                'status': status,
                'status_text': status_text
            })
        
        pages = (total + per_page - 1) // per_page
        return render_template('index.html', devices=devices_data, page=page, pages=pages,
                             ip_filter=ip_filter, vlan_filter=vlan_filter, refresh_rate=refresh_rate,
                             notifications=notifications, vlans=vlans)

@app.route('/history/<ip>')
def history(ip):
    with sqlite3.connect('network.db') as conn:
        c = conn.cursor()
        c.execute('SELECT start_time, end_time, duration FROM history WHERE ip = ? ORDER BY start_time DESC', (ip,))
        sessions = []
        for row in c.fetchall():
            start_time, end_time, duration = row
            sessions.append({
                'start': datetime.fromtimestamp(start_time).strftime('%Y-%m-%d %H:%M:%S'),
                'end': datetime.fromtimestamp(end_time).strftime('%Y-%m-%d %H:%M:%S') if end_time else 'Ongoing',
                'duration': f"{int(duration // 60)}m {int(duration % 60)}s" if duration else 'Ongoing'
            })
        return render_template('history.html', ip=ip, sessions=sessions)

# Start async loop
if platform.system() == "Emscripten":
    asyncio.ensure_future(ping_vlans())
else:
    if __name__ == "__main__":
        init_db()
        socketio.start_background_task(ping_vlans)
        socketio.run(app, debug=True)
