import os
import threading
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import queue
import time

try:
    import docx
    import openpyxl
except ImportError:
    docx = None
    openpyxl = None


class AdvancedFileSearcher:
    def __init__(self, root):
        self.root = root
        self.root.title("Advanced File Searcher")

        self.locations = []
        self.should_continue = True
        self.result_queue = queue.Queue()
        self.search_thread = None
        self.match_count = 0

        self.setup_gui()

    def setup_gui(self):
        frame = ttk.Frame(self.root, padding="10")
        frame.grid(row=0, column=0, sticky="nsew")

        # Search Locations
        ttk.Label(frame, text="Search Locations:").grid(row=0, column=0, sticky="w")
        self.location_listbox = tk.Listbox(frame, height=4, width=60)
        self.location_listbox.grid(row=1, column=0, columnspan=3, sticky="we")
        ttk.Button(frame, text="Add Folder", command=self.add_location).grid(row=1, column=3)
        ttk.Button(frame, text="Remove Selected", command=self.remove_location).grid(row=1, column=4)

        # Keyword
        ttk.Label(frame, text="Keyword:").grid(row=2, column=0, sticky="w")
        self.keyword_entry = ttk.Entry(frame, width=30)
        self.keyword_entry.grid(row=2, column=1, columnspan=2, sticky="we")

        # Match type
        self.match_type = tk.StringVar(value="contains")
        ttk.Label(frame, text="Match Type:").grid(row=3, column=0, sticky="w")
        match_frame = ttk.Frame(frame)
        match_frame.grid(row=3, column=1, columnspan=3, sticky="w")
        for text, val in [("Contains", "contains"), ("Exact", "exact"),
                          ("Starts With", "starts"), ("Ends With", "ends")]:
            ttk.Radiobutton(match_frame, text=text, variable=self.match_type, value=val).pack(side="left")

        # Search options
        self.search_name = tk.BooleanVar(value=True)
        self.search_dir_name = tk.BooleanVar(value=False)
        self.search_content = tk.BooleanVar(value=False)
        self.include_subdirs = tk.BooleanVar(value=True)
        ttk.Checkbutton(frame, text="Search File Name", variable=self.search_name).grid(row=4, column=0, sticky="w")
        ttk.Checkbutton(frame, text="Search Directory Name", variable=self.search_dir_name).grid(row=4, column=1, sticky="w")
        ttk.Checkbutton(frame, text="Search Inside File Content", variable=self.search_content).grid(row=4, column=2, sticky="w")
        ttk.Checkbutton(frame, text="Include Subdirectories", variable=self.include_subdirs).grid(row=4, column=3, sticky="w")

        # File Types
        ttk.Label(frame, text="File Types to Search (e.g., txt,bat,xlsx):").grid(row=5, column=0, sticky="w")
        self.file_types_entry = ttk.Entry(frame, width=40)
        self.file_types_entry.insert(0, "txt,docx,xlsx")
        self.file_types_entry.grid(row=5, column=1, columnspan=3, sticky="we")

        # Time filter
        self.time_limit_var = tk.BooleanVar()
        ttk.Checkbutton(frame, text="Only include files saved in the last X minutes:", variable=self.time_limit_var).grid(row=6, column=0, sticky="w")
        self.time_limit_entry = ttk.Entry(frame, width=10)
        self.time_limit_entry.insert(0, "15")
        self.time_limit_entry.grid(row=6, column=1, sticky="w")

        # Exclude folders
        ttk.Label(frame, text="Exclude Folders (comma-separated):").grid(row=7, column=0, sticky="w")
        self.exclude_entry = ttk.Entry(frame, width=40)
        self.exclude_entry.insert(0, "node_modules,__pycache__")
        self.exclude_entry.grid(row=7, column=1, columnspan=3, sticky="we")

        # Search type: Files / Dirs / Both
        self.search_for = tk.StringVar(value="files")
        ttk.Label(frame, text="Search For:").grid(row=8, column=0, sticky="w")
        search_for_frame = ttk.Frame(frame)
        search_for_frame.grid(row=8, column=1, columnspan=3, sticky="w")
        for text, val in [("Files", "files"), ("Directories", "dirs"), ("Both", "both")]:
            ttk.Radiobutton(search_for_frame, text=text, variable=self.search_for, value=val).pack(side="left")

        # Buttons
        self.search_btn = ttk.Button(frame, text="Start Search", command=self.start_search_thread)
        self.search_btn.grid(row=9, column=0, columnspan=3, pady=10, sticky="ew")
        self.stop_btn = ttk.Button(frame, text="Stop Search", command=self.stop_search, state="disabled")
        self.stop_btn.grid(row=9, column=3, columnspan=2, sticky="ew")

        # Results
        self.results_box = tk.Text(frame, height=15, wrap="none")
        self.results_box.grid(row=10, column=0, columnspan=5, sticky="nsew")

        # Status bar
        self.status_label = ttk.Label(frame, text="Status: Idle", anchor="w")
        self.status_label.grid(row=11, column=0, columnspan=5, sticky="we")

    def add_location(self):
        folder = filedialog.askdirectory()
        if folder:
            self.locations.append(folder)
            self.location_listbox.insert(tk.END, folder)

    def remove_location(self):
        selected = self.location_listbox.curselection()
        for i in reversed(selected):
            self.location_listbox.delete(i)
            del self.locations[i]

    def match_keyword(self, keyword, target):
        target = target.lower()
        keyword = keyword.lower()
        match_type = self.match_type.get()
        if match_type == "contains": return keyword in target
        if match_type == "exact": return keyword == target
        if match_type == "starts": return target.startswith(keyword)
        if match_type == "ends": return target.endswith(keyword)
        return False

    def search_in_file(self, filepath, keyword):
        ext = os.path.splitext(filepath)[1].lower()
        try:
            if ext == ".txt":
                with open(filepath, "r", errors="ignore") as f:
                    return any(self.match_keyword(keyword, line) for line in f)
            elif ext == ".docx" and docx:
                doc = docx.Document(filepath)
                return any(self.match_keyword(keyword, para.text) for para in doc.paragraphs)
            elif ext == ".xlsx" and openpyxl:
                wb = openpyxl.load_workbook(filepath, read_only=True)
                for sheet in wb.worksheets:
                    for row in sheet.iter_rows(values_only=True):
                        if any(cell and self.match_keyword(keyword, str(cell)) for cell in row):
                            return True
        except:
            pass
        return False

    def start_search_thread(self):
        if not self.keyword_entry.get().strip():
            messagebox.showwarning("Input Error", "Please enter a keyword.")
            return
        if not self.locations:
            messagebox.showwarning("Input Error", "Please add at least one location.")
            return

        self.results_box.delete("1.0", tk.END)
        self.should_continue = True
        self.match_count = 0
        self.search_btn.config(state="disabled")
        self.stop_btn.config(state="normal")
        self.status_label.config(text="Status: Searching...")

        self.search_thread = threading.Thread(target=self.perform_search)
        self.search_thread.start()
        self.root.after(100, self.check_result_queue)

    def stop_search(self):
        self.should_continue = False
        self.stop_btn.config(state="disabled")
        self.status_label.config(text="Status: Cancelling...")

    def check_result_queue(self):
        try:
            while not self.result_queue.empty():
                result = self.result_queue.get_nowait()
                self.results_box.insert(tk.END, result + "\n")
                self.match_count += 1
                self.status_label.config(text=f"Status: Searching... {self.match_count} matches found")
        except queue.Empty:
            pass

        if self.search_thread and self.search_thread.is_alive():
            self.root.after(100, self.check_result_queue)
        else:
            self.search_btn.config(state="normal")
            self.stop_btn.config(state="disabled")
            if self.should_continue:
                self.status_label.config(text=f"Status: Completed. {self.match_count} matches found.")
            else:
                self.status_label.config(text=f"Status: Stopped by user. {self.match_count} matches shown.")

    def perform_search(self):
        keyword = self.keyword_entry.get().strip()
        file_types_raw = self.file_types_entry.get().strip()
        file_types = [f".{ft.strip().lstrip('.')}" for ft in file_types_raw.split(",") if ft.strip()]
        search_for = self.search_for.get()

        excluded_folders = [f.strip().lower() for f in self.exclude_entry.get().split(",") if f.strip()]

        if self.time_limit_var.get():
            try:
                minutes = int(self.time_limit_entry.get())
                time_cutoff = time.time() - minutes * 60
            except ValueError:
                time_cutoff = None
        else:
            time_cutoff = None

        for location in self.locations:
            for root_dir, dirs, files in os.walk(location):
                if not self.should_continue:
                    return

                # Exclude folders
                dirs[:] = [d for d in dirs if d.lower() not in excluded_folders]

                self.status_label.config(text=f"Searching: {root_dir}")

                targets = []
                if search_for in ("files", "both"):
                    targets += [os.path.join(root_dir, f) for f in files if not file_types or os.path.splitext(f)[1].lower() in file_types]
                if search_for in ("dirs", "both"):
                    targets += [os.path.join(root_dir, d) for d in dirs]

                for path in targets:
                    if not self.should_continue:
                        return

                    is_file = os.path.isfile(path)
                    is_dir = os.path.isdir(path)
                    name = os.path.basename(path)

                    if is_file and time_cutoff:
                        try:
                            mod_time = os.path.getmtime(path)
                            if mod_time < time_cutoff:
                                continue
                        except:
                            continue

                    matched = False
                    if is_file and self.search_name.get() and self.match_keyword(keyword, name):
                        matched = True
                    elif is_dir and self.search_dir_name.get() and self.match_keyword(keyword, name):
                        matched = True
                    elif is_file and self.search_content.get() and os.path.splitext(path)[1].lower() in file_types:
                        if self.search_in_file(path, keyword):
                            matched = True

                    if matched:
                        self.result_queue.put(path)

                if not self.include_subdirs.get():
                    break


if __name__ == "__main__":
    root = tk.Tk()
    app = AdvancedFileSearcher(root)
    root.mainloop()
